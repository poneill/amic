
* Overview
  In this lab we'll apply the Metropolis-Hastings algorithm to a
  synthetic ChIP-Seq dataset in order to recover a model of the
  DNA-binding domain of our synthetic transcription factor (TF).  Gray
  boxes with text

: like this

  represent commands to be typed.  Empty gray boxes like:

: 

  indicate that there is a question to be answered.

* Preliminaries
  Download this repository from =github.com/poneill/xxx=.  Explore the
  code interactively by typing:

: $ python -i lab.py

  or open the file in emacs and send the buffer to a python REPL using
  =M-x python-shell-send-buffer= (or equivalent).  This is just a
  convenience file that imports data and functions defined in other
  files.  All of the code in this lab is contained in the =lab.py=
  namespace, but you may wish to open the other files to examine the
  code, poke around and see what's going on.

* =data.py=
The script first imports the contents of =data.py=: let's see what's
defined there.

Inspect the variable =TRUE_ENERGY_MATRIX=.  You can use the
pretty-print function (=pprint=) to display it more clearly.  

What is the width of the site that the true binding model recognizes?

: 

What is the length of the =GENOME=?

: 

* =energy_matrix.py=

  This file contains some functions related to energy matrices and their use.

  The most important function in this file is =score=, which computes
  the score of =sequence= with respect to an =energy_matrix=.  Try
  computing the scores of various strings under the
  =TRUE_ENERGY_MATRIX=.  Remember that the scores have dimensions of
  $\Delta G$, so lower scores represent stronger binding sites.  In
  our toy model, what is our TF looking for?  Inspect the energy
  matrix directly or experiment with various strings, for example:

: >>> score(TRUE_ENERGY_MATRIX,"ACGATGACGT")

 in order to describe the motif that the TF binds:

: 

  Notice also the function =score_genome=, which scores the entire
  genome at once.  In this toy model, we consider the genome to be
  linearized, rather than circular, and consider binding only in the
  5'-3' direction: we neglect the complementary strand.  Define the
  following variable:

: >>> scores = score_genome(TRUE_ENERGY_MATRIX,GENOME)

  What is the relationship between =scores= and =GENOME=?  Draw a
  diagram that explains this relationship.

: 

* =metropolis_hastings.py=

  This file contains an implementation of the Metropolis-Hastings
  algorithm, with one crucial simplification.  What is the difference
  between the implementation given here, and the algorithm described
  on Wednesday?  (Hint: it is not the =use_log= option, which is just a
  numerical convenience).  How does it restrict our use of the =mh=
  function?

: 

* =simulate_tf.py=

  This file contains functions for simulating the behavior of the tf
  on the chromosome, in two ways.  The first method, =simulate=,
  reports the position of the TF when simulated via the M-H algorithm.

  If only a single copy of the TF is present within the cell, as we
  will assume, the occupation probability for a site with binding
  energy $s_i$ is given by $\frac{exp(-\beta s_i)}{Z}$, where
  $Z=\sum_i exp(-\beta s_i)$ is the sum of the expression in the
  numerator over all sites, and we choose units such that $\beta=1$.

  Note that in the inner function =binding_probability=, this
  expression is defined only up to a constant-- the M-H algorithm
  allows us to neglect the computation of $Z$, which is convenient
  when the genome is large and there are many possible binding sites.

* =chip_seq.py=

  This file implements the simulation of ChIP-seq datasets.  For as
  many fragments as desired, we first sample the position of the TF on
  the chromosome according to its binding distribution.  We then
  sample the length of the fragment which contains the position where
  the TF is bound, according to a Poisson distribution with fixed
  =MEAN_FRAGMENT_LENGTH=.  Finally, we sample the displacement of the
  left endpoint of the fragment from the binding site, which is
  uniformly distributed within the fragment.  This is mathematically
  equivalent to the more physically faithful process of fixing the
  position of the TF, fragmenting the genome randomly and picking the
  fragment which contains the bound position, but more efficient.

* =inference.py=

  Now we arrive at the central problem: suppose we are given a
  ChIP-seq dataset, and we wish to make an inference about the binding
  matrix which gave rise to it.  Formally, we want to sample from the
  posterior probability P(M|D) over matrices M, given data D.  

  Use Bayes' theorem in order to write P(M|D) in terms of the
  likelihood P(D|M) and the prior probability P(M):

:

  Now assume the prior P(M) is uniform, and assume a likelihood
  function of the form given on Wednesday.  Show that, if the
  likelihood function only interacts with our sampling algorithm
  through the ratio $\frac{P(D|H_i)}{P(D|H_j)}$, we can simplify the
  resulting expression.  Rewrite the new likelihood function in its
  simplified form and explain in your own words what is going on:

:

  Now we are ready to sample matrices from the posterior distribution
  P(M|D).  Use the function =sample_posterior= as follows:

: >>> matrix_chain, fragments = sample_posterior()

  The return values are a =matrix_chain=, consisting of pairs of
  matrices and their associated log-likelihood values =(m,logf(m))=,
  and the set of fragments used to compute the log-likelihood.
  Compare the resulting log-likelihoods to the log-likelihood of the
  =TRUE_ENERGY_MATRIX=, which is printed to =stdout= when
  =sample_posterior= runs.  Are they comparable?

:

  We saw on Wednesday that the proposal distribution often contains a
  tuning parameter which controls the correlation between the proposed
  and current states.  Often, the performance of MCMC algorithms is
  sensitive to such parameters.  Here, the tuning parameter is
  =sigma=, which controls the standard deviation of the Gaussian
  random variable which is added to a random component of the current
  energy matrix at each step.  Try varying sigma.  This can be done by
  typing, e.g.,:

: >>> sample_posterior(sigma=1,fragments=fragments)

  at the REPL.  (We pass =fragment= back in as an argument so that we
  do not regenerate a new set of fragments on the fly, potentially
  invalidating the comparison.) How does the performance of the
  algorithm depend on =sigma=?  What seems to give the fastest
  approach to high-probability regions of the posterior distribution?
  How is the acceptance efficiency affected?

:

  Find the posterior mode of the chain, that is, the matrix with the
  highest posterior probability.  This can be done with the following command:

: >>> post_mode = max(matrix_chain,key=lambda (m,pm):pm)

  and examine the matrix visually (you may find =pprint= helpful again
  here).  What similarities, if any, do you see between the 'best'
  matrix in the chain and the true energy matrix?  What differences?

:

